% Created 2020-07-22 Wed 19:28
% Intended LaTeX compiler: pdflatex
\documentclass[letter]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage[margin=1.3in]{geometry}
\setlength{\columnsep}{1cm}
\usepackage{palatino}
\fontfamily{ppl}\selectfont
\usepackage[spanish]{babel}
\renewcommand{\baselinestretch}{1.5}
\usepackage{fancyhdr}
\fancyhf{}
\pagestyle{fancy}
\lhead{\hleft}
\rhead{\hright}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\hleft}{Procesamiento de imágenes}
\newcommand{\hright}{INF 324}
\author{Jesus Rodolfo Izurieta Veliz}
\date{\today}
\title{Procesamiento de imágenes}
\hypersetup{
 pdfauthor={Jesus Rodolfo Izurieta Veliz},
 pdftitle={Procesamiento de imágenes},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.4)}, 
 pdflang={Spanish}}
\begin{document}

\maketitle

\section{Introducción}
\label{sec:org853b42c}
El reconocimiento de objetos es la tarea de encontrar e identificar
automáticamente objetos en una imagen. Los humanos detectamos y reconocemos
objetos en imágenes con extrema facilidad, inclusive si los objetos sufren
variaciones de forma, tamaño, localización, color, textura, brillo o están
parcialmente obstruidos.

\section{Objetivos}
\label{sec:orgb4f4ba9}
\subsection{Objetivos generales}
\label{sec:org3742004}
Conteo de monedas en una fotografía (?)

\subsection{Objetivos específicos}
\label{sec:org0c6206b}

\section{Fundameentos teóricos}
\label{sec:orgc684dc2}
Para el tratamiento de una imagen digital, la representaremos como una función

$$ I:\mathbb N^2 \rightarrow [0, 1] $$
$$ I(x, y) $$

Donde el rango representa el nivel de luminosidad para los pixeles en
coordenadas x e y en el caso de imágenes en escala de grises, para imágenes a
color, tendremos tres funciones, una para cada uno de los colores rojo, verde y
azul. En el caso de una imagen digital, estos valores varían en el rango
\([0,255]\in \mathbb N\).

\section{Desarrollo}
\label{sec:org398a4de}
El proyecto no contará con una interfaz gráfica, sino que constará de un
notebook interactivo de jupyter en el que se podrá apreciar tanto el código
fuente como los resultados de cada paso del proceso de manipulado de las
imágenes. Para esto, se desarrollan las siguientes bibliotecas:

\subsection{Clase Image}
\label{sec:orgbf98c20}
La clase imagen es una abstracción básica que nos permitirá acceder fácilmente a
una imagen que puede ser cargada desde un archivo, o puede ser creada desde un
array y posteriormente mostrada en un notebook de jupyter.

\begin{center}
\begin{tabular}{ll}
Método & Descripción\\
\hline
\texttt{load\_file(ruta)} & Carga la imagen que se encuentra en la ruta\\
\texttt{load\_array(array)} & Convierte el array en una imagen\\
\texttt{show()} & Retorna un objeto PIL.Image.Image\\
\texttt{I(x, y)} & Retorna los píxeles en la posición x, y\\
\texttt{I\_normal(x, y)} & Igual que I() pero en el rango [0, 1]\\
\texttt{I\_m(x, y, color)} & Retorna un único pixel\\
\texttt{I\_mnormal(x, y, color)} & Igual que I\textsubscript{m}() pero en el rango [0, 1]\\
\texttt{iterator()} & Retorna un iterador de tuplas x, y\\
\texttt{map\_over(func)} & Permite sobreescribir píxeles mediante una función\\
\end{tabular}
\end{center}

La función \texttt{map\_over(func)} nos permitirá recorrer la totalidad de la imagen
aplicando en cada pixel la función \texttt{func}, por ejemplo el código
\texttt{img2.map\_over(lambda x, y, z: (x, x, x))} ejecutado sobre una imagen img2,
permitirá cambiar el valor de cada canal por su valor rojo, lo que convertirá a
la imagen a blanco y negro.

\subsection{Preprocesamiento}
\label{sec:org0abca92}

\subsubsection{Reducción de ruido}
\label{sec:orge5cbfa4}
\subsubsection{Corrección de iluminación}
\label{sec:org825a22b}

\subsection{Segmentación}
\label{sec:org6bd4302}

\subsection{Datos de comparación}
\label{sec:org30c838c}

\subsection{Procesamiento}
\label{sec:orgbbadae2}
\subsubsection{Momentos de Hu}
\label{sec:org2aee8f0}
Para obtener un valor propio de la forma geométrica de un objeto en una imagen,
usaremos momentos de Hu o momentos invariantes, un algoritmo que nos permite
obtener un conjunto de valores asignados a una matriz según la disposición que
esta tenga, sin variar en cuanto a transformaciones como escalado o rotación.

Los momentos de orden \((p+q)\) en dos dimensiones sobre una función de
distribución \(p(x, y)\) continua, son calculados mediante integrales de Riemman
como sigue:

$$
m_{pq} =  \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} x^p y^q p(x, y)\,dx\,dy \quad p, q = 0, 1, 2, ...
$$

Sin embargo, en el caso del tratamiento de imágenes, esta será la función
discreta \(I(x, y)\) que describa nuestra imagen en función de la posición de sus
pixeles.

\subsubsection{Extracción de rasgos}
\label{sec:org71c8ac6}
\subsubsection{Comparación cy clasificación}
\label{sec:org1ea058c}

\section{Pruebas}
\label{sec:org6a8b081}

\section{Conclusiones}
\label{sec:org770b5e5}

\section{Referencias}
\label{sec:org01f08c3}

\section{Anexos}
\label{sec:org1f5f1c1}
\subsection{Código fuente}
\label{sec:orgd410e19}
\subsubsection{Clase Imagen}
\label{sec:orgf92bca0}
\subsubsection{Filtrado ADF}
\label{sec:org82aa120}
\subsubsection{Filtrado Top-Hat}
\label{sec:org9b8c6f8}
\subsubsection{Filtrado Otsu}
\label{sec:org8c0ec14}
\subsubsection{Momentos de Hu}
\label{sec:org2809b90}
Obtención de momentos geométricos de orden \(p+q\), \(m_{pq} = \sum_x \sum_y x^p y^q I(x, y)\).

\begin{verbatim}
def m_pq():
   
\end{verbatim}

\subsubsection{KNN}
\label{sec:org93ecd5c}

\subsection{Resultados}
\label{sec:org5a3f67e}
\end{document}
