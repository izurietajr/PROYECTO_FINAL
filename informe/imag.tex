% Created 2020-07-23 Thu 02:06
% Intended LaTeX compiler: pdflatex
\documentclass[letter]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage[margin=1.3in]{geometry}
\setlength{\columnsep}{1cm}
\usepackage{palatino}
\fontfamily{ppl}\selectfont
\usepackage[spanish]{babel}
\renewcommand{\baselinestretch}{1.5}
\usepackage{fancyhdr}
\fancyhf{}
\pagestyle{fancy}
\lhead{\hleft}
\rhead{\hright}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\hleft}{Procesamiento de imágenes}
\newcommand{\hright}{INF 324}
\author{Jesus Rodolfo Izurieta Veliz}
\date{\today}
\title{Procesamiento de imágenes}
\hypersetup{
 pdfauthor={Jesus Rodolfo Izurieta Veliz},
 pdftitle={Procesamiento de imágenes},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.4)}, 
 pdflang={Spanish}}
\begin{document}

\maketitle

\section{Introducción}
\label{sec:org6719cc1}
El reconocimiento de objetos es la tarea de encontrar e identificar
automáticamente objetos en una imagen. Los humanos detectamos y reconocemos
objetos en imágenes con extrema facilidad, inclusive si los objetos sufren
variaciones de forma, tamaño, localización, color, textura, brillo o están
parcialmente obstruidos.

\section{Objetivos}
\label{sec:orgb571ec8}
\subsection{Objetivo general}
\label{sec:org6b8c26c}
\begin{itemize}
\item Desarrollo de una biblioteca para reconocimiento de objetos en imágenes sin
hacer uso de métodos avanzados de inteligencia artificial como redes
neuronales.
\end{itemize}

\subsection{Objetivos específicos}
\label{sec:org179c8e9}
\begin{itemize}
\item Desarrollo de una biblioteca que permita una cómoda manipulación de imágenes
para su procesamiento.
\item Expansión de la biblioteca de procesamiento de imágenes implementando
diferentes algoritmos de preprocesamiento de imágenes.
\item Desarrollo de un notebook destallando paso a paso el uso de la biblioteca para
un caso específico.
\end{itemize}

\section{Fundamentos teóricos}
\label{sec:org46c3e8e}
Primeramente definiremos algunos conceptos que utilizaremos en el desarrollo del
proyecto. Para el tratamiento de una imagen digital, la representaremos como una
función de la posición de sus pixeles como sigue:

$$ I:\mathbb N^2 \rightarrow [0, 1] $$
$$ I(x, y) $$

Donde el rango representa el nivel de luminosidad para los pixeles en
coordenadas x e y en el caso de imágenes en escala de grises, para imágenes a
color, tendremos en su lugar una tupla de tres elementos, uno para cada uno de
los colores rojo, verde y azul. En el caso de una imagen digital, estos valores
varían en el rango \([0,255]\in \mathbb N\).

\section{Desarrollo}
\label{sec:org705fda3}
El proyecto no contará con una interfaz gráfica, sino que constará de un
notebook interactivo de jupyter en el que se podrá apreciar tanto el código
fuente como los resultados de cada paso del proceso de manipulado de las
imágenes. Para esto, se desarrollan las siguientes bibliotecas:

\subsection{Clase Image}
\label{sec:org18ec30b}
La clase imagen es una abstracción básica que nos permitirá acceder y manipular
fácilmente una imagen que puede ser cargada desde un archivo, o puede ser creada
desde un array y posteriormente mostrada en un notebook de jupyter.

\begin{description}
\item[{Load file:}] (Parámetros: ruta) Carga en la instancia la imagen que se
encuentra en la ruta y la convierte en una matriz de tuplas de 3 componentes,
uno por cada color RGB, almacenándola en el atributo \texttt{array} de la clase
imagen, además define otros atributos como las dimensiones de la imagen.

\item[{Load array:}] (Parámetros: array) Almacena una matriz en el atributo \texttt{array}
de la imagen, la matriz debe ser una matriz de tuplas de tres valores.

\item[{Show:}] Retorna un objeto PIL.Image.Image que permite visualizar la imagen en
un notebook de jupyter o almacenarla como un archivo.

\item[{I:}] (Parámetros: x, y) Representa la función \(I(x, y)\) definida previamente,
retorna los píxeles en la posición x, y como una tupla de 3 valores.

\item[{I normal:}] (Parámetros: x, y) Igual que I() pero en lugar de retornar
valores en el rango [0, 255] normaliza los valores al rango [0, 1].

\item[{I m:}] (Parámetros: x, y, color) Igual que I(), pero retorna un único valor
definido por el parámetro \texttt{color}, 0 para rojo, 1 para verde y 2 para azul, el
valor por defecto es rojo si no se define el parámetro color.

\item[{I mnormal:}] (Parámetros: x, y, color) Igual que I\textsubscript{m}() pero con valores
normalizados en el rango [0, 1]

\item[{Iterator:}] Retorna un iterador de tuplas x, y que facilita iteraciones
sobre cada píxel de la imagen.

\item[{Map over:}] (Parámetros: func) Permite sobreescribir píxeles mediante una
función que se envía como parámetro, la función recibirá una tupla de 3
valores y debe devolver una tupla de 3 valores. Esta función nos permitirá
recorrer la totalidad de la imagen aplicando en cada pixel la función \texttt{func},
por ejemplo el código \texttt{img.map\_over(lambda x, y, z: (x, x, x))} ejecutado
sobre una imagen img2, permitirá cambiar el valor de cada canal por su valor
rojo, lo que convertirá a la imagen a blanco y negro.
\end{description}

\subsection{Preprocesamiento}
\label{sec:orgb4e4ab9}

\subsubsection{Reducción de ruido}
\label{sec:org508f02e}
\subsubsection{Corrección de iluminación}
\label{sec:org0ac49c2}

\subsection{Segmentación}
\label{sec:org16058d6}

\subsection{Procesamiento}
\label{sec:orge8d8900}
\subsubsection{Momentos de Hu}
\label{sec:org1b75ed7}
Para obtener un valor propio de la forma geométrica de un objeto en una imagen,
usaremos momentos de Hu o momentos invariantes, un algoritmo que nos permite
obtener un conjunto de valores asignados a una matriz según la disposición que
esta tenga, sin variar en cuanto a transformaciones como escalado o rotación.

Los momentos de orden \((p+q)\) en dos dimensiones sobre una función de
distribución \(p(x, y)\) continua, son calculados mediante integrales de Riemman
como sigue:

$$
m_{pq} =  \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} x^p y^q p(x, y)\,dx\,dy \quad p, q = 0, 1, 2, ...
$$

Sin embargo, en el caso del tratamiento de imágenes, esta será la función
discreta \(I(x, y)\) que describa nuestra imagen en función de la posición de sus
pixeles, por lo que la definición de momentos usada será:

$$
m_{pq} = \sum_x \sum_y x^p y^q I(x, y)
$$

\subsubsection{Extracción de rasgos}
\label{sec:org4afb5fa}

\subsubsection{Datos de comparación}
\label{sec:org937b601}

\subsubsection{Comparación y clasificación}
\label{sec:org7b26736}

\section{Pruebas}
\label{sec:orgb82c766}

\section{Conclusiones}
\label{sec:orge31a72d}

\section{Referencias}
\label{sec:orgf761fac}

\section{Anexos}
\label{sec:org2923473}
\subsection{Código fuente}
\label{sec:org8605cfc}
\subsubsection{Clase Imagen}
\label{sec:orgf426849}
\subsubsection{Filtrado ADF}
\label{sec:orga277585}
\subsubsection{Filtrado Top-Hat}
\label{sec:org60eefe0}
\subsubsection{Filtrado Otsu}
\label{sec:org5e25457}
\subsubsection{Momentos de Hu}
\label{sec:org3f7e957}
Obtención de momentos geométricos de orden \(p+q\), \(m_{pq} = \sum_x \sum_y x^p y^q I(x, y)\).

\begin{verbatim}
def m_pq():
   
\end{verbatim}

\subsubsection{KNN}
\label{sec:org236f6c6}

\subsection{Resultados}
\label{sec:orgfe020a8}
\end{document}
